
import { GoogleGenAI, Chat, GenerateContentResponse, Type } from "@google/genai";
import { AnalysisResult } from '../types';

const getClient = () => new GoogleGenAI({ apiKey: process.env.API_KEY });

async function withRetry<T>(fn: () => Promise<T>, maxRetries = 3): Promise<T> {
  let lastError: any;
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (err: any) {
      lastError = err;
      const status = err?.status || 0;
      const message = err?.message?.toLowerCase() || "";
      
      if (status === 503 || status === 429 || message.includes("overloaded") || message.includes("busy") || message.includes("resource has been exhausted")) {
        const delay = Math.pow(2, i) * 1000 + (Math.random() * 500);
        console.warn(`Model busy/rate limited. Retry ${i + 1}/${maxRetries}...`);
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }
      throw err;
    }
  }
  throw lastError;
}

// Define formal schema for deterministic JSON output
const ANALYSIS_SCHEMA = {
  type: Type.OBJECT,
  properties: {
    accuracyRating: { type: Type.NUMBER, description: "1-10 rating of factual accuracy" },
    overallSentiment: { type: Type.STRING, description: "Positive, Negative, or Neutral" },
    summary: { type: Type.STRING, description: "Detailed summary of the video content and verification results" },
    keyTakeaways: { 
      type: Type.ARRAY, 
      items: { type: Type.STRING },
      description: "List of 3-5 major insights" 
    },
    claims: {
      type: Type.ARRAY,
      items: {
        type: Type.OBJECT,
        properties: {
          claim: { type: Type.STRING },
          verdict: { type: Type.STRING, description: "True, False, Misleading, Unverified, or Mixed" },
          confidenceScore: { type: Type.NUMBER, description: "0-10" },
          explanation: { type: Type.STRING }
        },
        required: ["claim", "verdict", "confidenceScore", "explanation"]
      }
    },
    commentAnalysis: {
      type: Type.OBJECT,
      properties: {
        overallSentiment: { type: Type.STRING },
        sentimentScore: { type: Type.NUMBER },
        dominantEmotions: { type: Type.ARRAY, items: { type: Type.STRING } },
        logicalFallacies: { type: Type.ARRAY, items: { type: Type.STRING } },
        botProbabilityScore: { type: Type.NUMBER },
        summary: { type: Type.STRING }
      },
      required: ["overallSentiment", "sentimentScore", "dominantEmotions", "logicalFallacies", "botProbabilityScore", "summary"]
    }
  },
  required: ["accuracyRating", "overallSentiment", "summary", "keyTakeaways", "claims", "commentAnalysis"]
};

const ANALYSIS_SYSTEM_PROMPT = `You are INFAKT, an elite Fact-Checking and Media Analysis Engine. Follow the SIFT methodology (Stop, Investigate source, Find better coverage, Trace context). Perform rigorous Google Searches to verify claims against external reality.`;

const extractVideoId = (url: string): string | null => {
  const regExp = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#&?]*).*/;
  const match = url.match(regExp);
  return (match && match[7].length === 11) ? match[7] : null;
};

const cleanVTT = (raw: string): string => {
    try {
        let text = raw.replace(/^WEBVTT.*\n/g, '');
        text = text.replace(/\d{2}:\d{2}:\d{2}\.\d{3} --> \d{2}:\d{2}:\d{2}\.\d{3}.*/g, '');
        text = text.replace(/<[^>]*>/g, '');
        const lines = text.split('\n').map(l => l.trim()).filter(l => l.length > 0 && !l.match(/^\d+$/));
        return [...new Set(lines)].join(' '); 
    } catch (e) { return raw; }
};

interface ScrapedData {
    title: string;
    description: string;
    author: string;
    transcript: string | null;
    comments: string | null;
}

async function fetchYouTubeData(videoId: string): Promise<ScrapedData | null> {
    const API_BASE = 'https://pipedapi.kavin.rocks';
    try {
        const streamRes = await fetch(`${API_BASE}/streams/${videoId}`);
        if (!streamRes.ok) throw new Error("Stream fetch failed");
        const streamData = await streamRes.json();
        
        let commentsText = "";
        try {
            const commentsRes = await fetch(`${API_BASE}/comments/${videoId}`);
            if (commentsRes.ok) {
                const commentsData = await commentsRes.json();
                commentsText = commentsData.comments
                    ? commentsData.comments.slice(0, 40).map((c: any) => `[User: ${c.author}] ${c.commentText}`).join("\n")
                    : "";
            }
        } catch (e) {}

        let transcriptText = null;
        if (streamData.subtitles && streamData.subtitles.length > 0) {
            const enSubtitle = streamData.subtitles.find((s: any) => s.code === 'en' && !s.autoGenerated) 
                               || streamData.subtitles.find((s: any) => s.code === 'en')
                               || streamData.subtitles[0];
            if (enSubtitle) {
                try {
                    const subRes = await fetch(enSubtitle.url);
                    const subRaw = await subRes.text();
                    transcriptText = cleanVTT(subRaw);
                } catch (e) {}
            }
        }

        return {
            title: streamData.title,
            description: streamData.description,
            author: streamData.uploader,
            transcript: transcriptText ? transcriptText.substring(0, 25000) : null,
            comments: commentsText ? commentsText.substring(0, 10000) : null
        };
    } catch (e) { return null; }
}

async function getBasicMetadata(url: string): Promise<{ title: string; author_name: string } | null> {
  try {
    const response = await fetch(`https://noembed.com/embed?url=${encodeURIComponent(url)}`);
    const data = await response.json();
    if (data.error || !data.title) return null;
    return { title: data.title, author_name: data.author_name };
  } catch (e) { return null; }
}

export const analyzeContent = async (url: string): Promise<AnalysisResult> => {
  const ai = getClient();
  const videoId = extractVideoId(url);
  
  let contentContext = "";
  let scrapedData: ScrapedData | null = null;

  if (videoId) scrapedData = await fetchYouTubeData(videoId);

  if (scrapedData) {
      contentContext = `
      VIDEO TITLE: "${scrapedData.title}"
      AUTHOR: "${scrapedData.author}"
      URL: ${url}
      TRANSCRIPT: ${scrapedData.transcript || "Unavailable"}
      COMMENTS: ${scrapedData.comments || "Unavailable"}
      `;
  } else {
      const metadata = await getBasicMetadata(url);
      contentContext = metadata 
        ? `TITLE: "${metadata.title}" AUTHOR: "${metadata.author_name}" URL: ${url}` 
        : `URL: ${url}`;
  }

  const prompt = `Analyze the following video content and verify its claims using Search Grounding: ${contentContext}`;

  return withRetry(async () => {
    const response = await ai.models.generateContent({
      model: 'gemini-3-flash-preview',
      contents: [{ parts: [{ text: prompt }] }],
      config: {
        systemInstruction: ANALYSIS_SYSTEM_PROMPT,
        tools: [{ googleSearch: {} }],
        thinkingConfig: { thinkingBudget: 4096 },
        maxOutputTokens: 8000, // Reserve space for the final JSON response
        responseMimeType: "application/json",
        responseSchema: ANALYSIS_SCHEMA
      },
    });

    const data = JSON.parse(response.text) as AnalysisResult;

    const sources = response.candidates?.[0]?.groundingMetadata?.groundingChunks
      ?.map((chunk: any) => chunk.web)
      .filter((web: any) => web && web.uri && web.title) || [];

    return {
      ...data,
      keyTakeaways: data.keyTakeaways || [],
      sources: sources as { title: string; uri: string }[],
    };
  });
};

export const createChatSession = () => {
  const ai = getClient();
  return ai.chats.create({
    model: 'gemini-3-flash-preview',
    config: {
      systemInstruction: "You are INFAKT, an expert fact-checker assistant. Answer follow-up questions accurately based on the analysis context provided.",
    },
  });
};

export const sendMessageToChat = async (chat: Chat, message: string): Promise<string> => {
    return withRetry(async () => {
        const response: GenerateContentResponse = await chat.sendMessage({ message });
        return response.text || "I couldn't generate a response.";
    });
};
